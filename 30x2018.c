#pragma config(Motor,  port2,           frontLeft,     tmotorVex393, openLoop)
#pragma config(Motor,  port3,           rearLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port4,           frontRight,    tmotorVex393, openLoop)
#pragma config(Motor,  port5,           rearRight,     tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)# pragma autonomousDuration(20)# pragma userControlDuration(120)

#include "Vex_Competition_Includes.c" //Main competition background code...do not modify!


int auton_level = 1;

void pre_auton() {}

task LCD() {

	/*0:	No buttons pressed
	1:	Left button is pressed
	2:	Center button is pressed
	3:	Left and Center buttons are pressed
	4:	Right button is pressed
	5:	Left and Right buttons are pressed
	6:	Center and Right buttons are pressed
	7:	Left, Center, and Right buttons are pressed
	*/
	int current_button = 0;
	int last_button = 0;
	int select = 0;
	int displevel = 1;
	string mainBattery;
	string auton_text;
	while (1) {
		bLCDBacklight = true;
		sprintf(mainBattery, "Bat: %1.2f%c", nImmediateBatteryLevel / 1000.0, 'V'); //Build the value to be displayed
		displayLCDCenteredString(0, mainBattery);
		wait1Msec(100);
		switch (nLCDButtons) {
		case 1:
			last_button = current_button;
			current_button = 1;
			break;
		case 2:
			last_button = current_button;
			current_button = 2;
			break;
		case 4:
			last_button = current_button;
			current_button = 4;
			break;
		case 0:
			last_button = current_button;
			current_button = 0;
		default:
			break;
		}

		if (last_button != current_button) {
			switch (current_button) {
			case 0:
				break;
			case 1:
				displevel--;
				break;
			case 2:
				select = 1;
				break;
			case 4:
				displevel++;
				break;
			default:
				break;
			}
		}

		#define AUTON_MAX 10
		if (displevel > AUTON_MAX) {
			displevel = 1;
		} else if (displevel <= 0) {
			displevel = AUTON_MAX;
		}


		string selected;
		sprintf(selected, "Selected auton %d", displevel);


		if(select){
			displayLCDCenteredString(1, selected);
			auton_level = displevel;
			select=0;
		}

		else{
			sprintf(auton_text, "Auton: %d", auton_level);
			displayLCDCenteredString(1, auton_text);
		}


	}
}

task autonomous() {

}

#define MAX_SPEED 127

typedef struct {
	float frontLeft;
	float frontRight;
	float rearRight;
	float rearLeft;
} Outputs;

typedef struct {
	float rad;
	float speed;
} Joystick;

float get_val(Outputs *in, int i){
	switch(i){
		case 0: return in->frontLeft;
		case 1: return in->frontRight;
		case 2: return in->rearRight;
		case 3: return in->rearLeft;
	}
	//an error, resume operation
	return 0;
}

float MaxFloat(Outputs *nums){
	float maxValue = 0;
	float temp;
	int z = 0;
	for(z = 0; z <= 3; z++){
		temp = abs(get_val(nums, z));
		if(temp > maxValue)
			maxValue = temp;
	}
	return maxValue;
}


/* Main code for movement
 *
 * Note that rad and speeds are passed in from drive(),
 * and that the values are taken from the getPolar() function
 */
void move(float rad, float speed = 1, byte rotation = 0)
{
	if(speed > 0)
	{
		Outputs output;
		output.frontLeft = -MAX_SPEED * cos(PI/4 - rad) + rotation;
		output.frontRight =  MAX_SPEED * cos(PI/4 + rad) + rotation;
		output.rearRight =  MAX_SPEED * cos(PI/4 - rad) + rotation;
		output.rearLeft	= -MAX_SPEED * cos(PI/4 + rad) + rotation;

		float maxOutput = MaxFloat(&output);
		speed *= (MAX_SPEED / maxOutput);

		output.frontLeft *= speed;
		output.frontRight *= speed;
		output.rearLeft *= speed;
		output.rearRight *= speed;

		motor[frontLeft] = (byte)output.frontLeft;
		motor[frontRight] = (byte)output.frontRight;
		motor[rearLeft] = (byte)output.rearLeft;
		motor[rearRight] = (byte)output.rearRight;
	}
	//not moving, so rotation is allowed
	//needs to be fixed so movement + rotation is possible
	else if (abs(rotation) > 20)
	{
		motor[frontLeft] = -rotation;
		motor[frontRight] = -rotation;
		motor[rearLeft] = -rotation;
		motor[rearRight] = -rotation;
	}
	else
	{
		motor[frontLeft] = 0;
		motor[frontRight] = 0;
		motor[rearLeft] = 0;
		motor[rearRight] = 0;
	}
}



/* Basic trig...
 * atan of Ch3 and Ch4 gives the angle of the drive joystick
 * sqrt(Ch3^2 + Ch4^2) yields the amount the joystick is being pushed, which
 * is then taken out of 127
 *
 * Notice how we use pointers, so we don't need to return anything
 */
void getPolar(float *rad, float *speed, TVexJoysticks joy_x = Ch3, TVexJoysticks joy_y = Ch4) {
	byte x_val = vexRT[joy_x];
	byte y_val = vexRT[joy_y];
	//tolerances
	if((abs(x_val) < 20) && (abs(y_val) < 20)) {
		*rad = 0;
		*speed = 0;
	}
	else {
		*rad = atan2(y_val,x_val);
		float tmpSpeed = sqrt((y_val * y_val) + (x_val * x_val));
		*speed = tmpSpeed/127;
		if(*speed > 1) *speed = 1;
	}
}

task usercontrol() {
	while (1) {
		Joystick joystick;
		getPolar(&joystick.rad, &joystick.speed);

		if (vexRT[Btn8R] || vexRT[Btn8L]) {move(0, 0, 127*(vexRT[Btn8R]-vexRT[Btn8L]));continue;}
		if (vexRT[Btn7R] || vexRT[Btn7L]) {move(PI/2*(vexRT[Btn7R]-vexRT[Btn7L]), 127, 0);continue;}
		if (vexRT[Btn7U] || vexRT[Btn7D]) {move(vexRT[Btn7U] ? 0 : PI, 127, 0);continue;}
		move(joystick.rad, joystick.speed, vexRT[Ch1]);
	}
}
